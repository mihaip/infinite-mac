import * as varz from "./varz";
import * as cdrom from "./cd-rom";
import * as disk from "./disk";
import * as library from "./library";
import {canRenderSSR, renderSSR} from "./ssr";

export type Assets = {
    fetch: typeof fetch;
};

export type Env = {
    ETHERNET_ZONE: DurableObjectNamespace;
    VARZ: KVNamespace;
    DISK_BUCKET: R2Bucket;
    ASSETS: Assets;
};
const handler: ExportedHandler<Env> = {fetch: handleRequest};

export default handler;
export {EthernetZone} from "./ethernet-zone";

async function handleRequest(
    request: Request,
    env: Env,
    ctx: ExecutionContext
) {
    const url = new URL(request.url);
    const path = url.pathname.slice(1).split("/");
    if (path[0] === "zone") {
        const zoneName = path[1];
        const zoneId = env.ETHERNET_ZONE.idFromName(zoneName);
        const zone = env.ETHERNET_ZONE.get(zoneId);
        const zoneUrl = new URL(request.url);
        zoneUrl.pathname = "/" + path.slice(2).join("/");
        return zone.fetch(zoneUrl.toString(), request);
    }
    if (path[0] === "varz") {
        return varz.handleRequest(request, env.VARZ);
    }
    if (path[0] === "errorz") {
        return varz.handleErrorzRequest(request, env.VARZ);
    }
    if (path[0] === "CD-ROM") {
        return cdrom.handleRequest(url.pathname, request.method);
    }
    if (path[0] === "Library") {
        return library.handleRequest(request, env.ASSETS);
    }
    if (path[0] === "Disk") {
        return disk.handleRequest(request, env.DISK_BUCKET, ctx);
    }

    if (canRenderSSR(url)) {
        const ssrResponse = await renderSSR(request, env, url);
        if (ssrResponse) {
            return applyCommonHeaders(ssrResponse, url.pathname);
        }
    }

    const legacyDomainRedirect = getLegacyDomainRedirect(url);
    if (legacyDomainRedirect) {
        return Response.redirect(
            "https://infinitemac.org" + legacyDomainRedirect,
            301
        );
    }

    try {
        const assetResponse = await env.ASSETS.fetch(request);
        const response = new Response(assetResponse.body, assetResponse);
        const {pathname} = url;

        // Force a MIME type from the list at
        // https://support.cloudflare.com/hc/en-us/articles/200168396 to ensure
        // that the ROM and chunks get compressed.
        // Don't do do this for intermediate ?import requests generated by Vite
        // in dev mode, they need to be a script MIME type.
        if (
            [".rom", ".hda", "pram.bin", "nvram.bin"].some(ext =>
                pathname.endsWith(ext)
            ) &&
            !url.searchParams.has("import")
        ) {
            response.headers.set("Content-Type", "multipart/mixed");
        }

        return applyCommonHeaders(response, pathname);
    } catch (e) {
        console.error("Error serving asset:", e);

        const err = e as Error;
        return new Response(err.message || err.toString(), {status: 500});
    }
}

function applyCommonHeaders(response: Response, pathname: string) {
    response.headers.set("X-Content-Type-Options", "nosniff");
    if (pathname === "/embed") {
        response.headers.set("Cross-Origin-Resource-Policy", "cross-origin");
    } else {
        response.headers.set("X-Frame-Options", "DENY");
    }
    // Allow SharedArrayBuffer to work
    response.headers.set("Cross-Origin-Opener-Policy", "same-origin");
    response.headers.set("Cross-Origin-Embedder-Policy", "require-corp");
    // Allow the service worker to intercept all paths, even when
    // initiated from a year subpath.
    response.headers.set("Service-Worker-Allowed", "/");

    // Static content uses a content hash in the URL, so it can be cached
    // for a while (30 days).
    if (pathname.startsWith("/assets")) {
        response.headers.set("Cache-Control", `max-age=${60 * 60 * 24 * 30}`);
    }

    return response;
}

const LEGACY_DOMAINS: {[domain: string]: string} = {
    "system6.app": "/1991/System%206.0.8",
    "system7.app": "/1996/System%207.5.3",
    "kanjitalk7.app": "/1996/KanjiTalk%207.5.3",
    "macos8.app": "/1998/Mac%20OS%208.1",
    "macos9.app": "/2000/Mac%20OS%209.0.4",
};

function getLegacyDomainRedirect(url: URL): string | undefined {
    let appleTalkZone;
    let domain = url.hostname;
    const pieces = domain.split(".");
    if (pieces.length === 3) {
        appleTalkZone = pieces[0];
        domain = pieces.slice(1).join(".");
    }

    const redirectPath = LEGACY_DOMAINS[domain];
    if (!redirectPath) {
        return undefined;
    }
    const params = url.searchParams;
    if (appleTalkZone && appleTalkZone !== "www") {
        params.set("appleTalk", appleTalkZone);
    }
    let search = params.toString();
    if (search) {
        search = "?" + search;
    }
    return redirectPath + search + url.hash;
}
